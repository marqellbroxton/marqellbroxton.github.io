<!DOCTYPE html>
<html>
<head>
	<title>Sudoku Backtracking Game</title>
	<link rel="stylesheet" href="style.css">
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<body>
	<a href="index.html" class="button">Back</a>
	<h1>Sudoku</h1>
	<h4>Python Code:</h4>
	<h2>What I've Learned</h2>
	<p>I learned that this puzzle game is similar to debugging. One<br/>
	issue occuring from a line of other issues, making it so that you<br/> 
	have to backtrack and see where the problem begins. The<br/>
	algorithm here will use all the functions throughout the coding<br/>
	and will backtrack for me. The 'find' function will allow me<br/>
	to know if there's been a solution, returning true if there is.<br/>
	Checking each number 1-9 and entering them into each box<br/>
	to see if it's a valid entry. If it is a valid entry it'll<br/>
	enter it into the board and keep trying until one of the entries<br/>
	are correct. Once it goes through all the valid possiblities and<br/>
	none are true, it will then backtrack to the last answer to reset<br/>
	because the current answer can't be correct.<br/><br/><br/>
	</p>
	
	<h3>
		# solver.py<br/>

		def solve(bo):<br/>
			find = find_empty(bo)<br/>
			if not find:<br/>
				return True<br/>
			else:<br/>
				row, col = find<br/>

			for i in range(1,10):<br/>
				if valid(bo, i, (row, col)):<br/>
					bo[row][col] = i<br/>

					if solve(bo):<br/>
						return True<br/>

					bo[row][col] = 0<br/>

			return False<br/><br/><br/><br/><br/>


		def valid(bo, num, pos):<br/>
			# Check row<br/>
			for i in range(len(bo[0])):<br/>
				if bo[pos[0]][i] == num and pos[1] != i:<br/>
					return False<br/>

			# Check column<br/>
			for i in range(len(bo)):<br/>
				if bo[i][pos[1]] == num and pos[0] != i:<br/>
					return False<br/>

			# Check box<br/>
			box_x = pos[1] // 3<br/>
			box_y = pos[0] // 3<br/>

			for i in range(box_y*3, box_y*3 + 3):<br/>
				for j in range(box_x * 3, box_x*3 + 3):<br/>
					if bo[i][j] == num and (i,j) != pos:<br/>
						return False<br/>

			return True<br/><br/><br/><br/><br/>


		def print_board(bo):<br/>
			for i in range(len(bo)):<br/>
				if i % 3 == 0 and i != 0:<br/>
					print("- - - - - - - - - - - - - ")<br/>

				for j in range(len(bo[0])):<br/>
					if j % 3 == 0 and j != 0:<br/>
						print(" | ", end="")<br/>

					if j == 8:<br/>
						print(bo[i][j])<br/>
					else:<br/>
						print(str(bo[i][j]) + " ", end="")<br/>


		def find_empty(bo):<br/>
			for i in range(len(bo)):<br/>
				for j in range(len(bo[0])):<br/>
					if bo[i][j] == 0:<br/>
						return (i, j)  # row, col<br/>

			return None<br/>
	
	
	
	</h3>
	<p>Now here is where it'll check whether the board is valid or<br/>
	not and if the number along with the position is also valid.<br/>
	We'll check each element for the row and see if it is equal to<br/>
	the number we added. You can not have the same number in a row<br/>
	so we'll check for that and make a change in our entries if<br/>
	that's the case. The same will happen for each column as you<br/>
	can not have the same number entry in a single column. There<br/>
	are nine boxes/sections that contain nine numbers, which also<br/>
	can't have the same number within any of them. Knowing the box<br/>
	we want to work on (0,1,2), then having it muliplied by 3 will<br/>
	show which column and row (position) we are currently working<br/>
	on. It will return false if we find a duplicate or the entry<br/>
	is invalid, but if we run through all the checks and it is<br/>
	valid, it will return true.
	<br/><br/><br/><br/><br/></P>
	<p>You want to use the 'def' function to print the game board<br/>
	so we have a visual of what's happening. After every three<br/>
	rows we want to print a dashed line to seperate the nine<br/>
	boxes with their nine elements, creating an organized grid.<br/>
	The 'end' function just makes sure that it doesn't keep going<br/>
	for the same row but starts a new one after printing nine<br/>
	numbers across. It also keeps the numbers of each row and<br/>
	column within formation of the board. The 'find_empty' is for<br/>
	finding a empty square on the board and checking if it is<br/>
	equal to zero, if it is we'll get a return of<br/>
	(row,col), (y,x).
	</p>
</body>
</html>