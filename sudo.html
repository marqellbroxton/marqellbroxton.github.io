<!DOCTYPE html>
<html>
<head>
	<title>Sudoku Backtracking Game</title>
	<link rel="stylesheet" href="style.css" />
</head>
<body>
	<a href="index.html" class="button">Back</a>
	<h1>Sudoku</h1>
	<h4>Python Code:</h4>
	<h2>What I've Learned</h2>
	<p>I learned that this puzzle game is similar to debugging. One<br/>
	issue occuring from a line of other issues, making it so that you<br/> 
	have to backtrack and see where the problem begins. The algorithm<br/>
	here will use all the functions throughout the coding and will<br/> 
	backtrack for me. The 'find' function will allow me to know if<br/> 
	there's been a solution, returning true if there is. Checking each<br/> 
	number 1-9 and entering them into each box to see if it's a valid<br/>
	entry. If it is a valid entry it'll enter it into the board and keep<br/> 
	trying until one of the entries are correct. Once it goes through<br/>
	all the valid possiblities and none are true, it will then backtrack<br/> 
	to the last answer to reset because the current answer can't be correct.<br/><br/><br/>
	</p>
	
	<h3>
		# solver.py<br/>

		def solve(bo):<br/>
			find = find_empty(bo)<br/>
			if not find:<br/>
				return True<br/>
			else:<br/>
				row, col = find<br/>

			for i in range(1,10):<br/>
				if valid(bo, i, (row, col)):<br/>
					bo[row][col] = i<br/>

					if solve(bo):<br/>
						return True<br/>

					bo[row][col] = 0<br/>

			return False<br/><br/><br/><br/><br/>


		def valid(bo, num, pos):<br/>
			# Check row<br/>
			for i in range(len(bo[0])):<br/>
				if bo[pos[0]][i] == num and pos[1] != i:<br/>
					return False<br/>

			# Check column<br/>
			for i in range(len(bo)):<br/>
				if bo[i][pos[1]] == num and pos[0] != i:<br/>
					return False<br/>

			# Check box<br/>
			box_x = pos[1] // 3<br/>
			box_y = pos[0] // 3<br/>

			for i in range(box_y*3, box_y*3 + 3):<br/>
				for j in range(box_x * 3, box_x*3 + 3):<br/>
					if bo[i][j] == num and (i,j) != pos:<br/>
						return False<br/>

			return True<br/><br/><br/><br/><br/>


		def print_board(bo):<br/>
			for i in range(len(bo)):<br/>
				if i % 3 == 0 and i != 0:<br/>
					print("- - - - - - - - - - - - - ")<br/>

				for j in range(len(bo[0])):<br/>
					if j % 3 == 0 and j != 0:<br/>
						print(" | ", end="")<br/>

					if j == 8:<br/>
						print(bo[i][j])<br/>
					else:<br/>
						print(str(bo[i][j]) + " ", end="")<br/>


		def find_empty(bo):<br/>
			for i in range(len(bo)):<br/>
				for j in range(len(bo[0])):<br/>
					if bo[i][j] == 0:<br/>
						return (i, j)  # row, col<br/>

			return None<br/>
	
	
	
	</h3>
	<p>Now here is where it'll check whether the board is valid or not and<br/>
	if the number along with the position is also valid. We'll check each<br/>
	element for the row and see if it is equal to the number we added. You<br/> 
	can not have the same number in a row so we'll check for that and make<br/>
	a change in our entries if that's the case. The same will happen for each<br/>
	column as you can not have the same number entry in a single column.<br/>
	There are nine boxes/sections that contain nine numbers, which also<br/>
	can't have the same number within any of them. Knowing the box we<br/>
	want to work on (0,1,2), then having it muliplied by 3 will show which<br/>
	column and row (position) we are currently working on. It will return<br/>
	false if we find a duplicate or the entry is invalid, but if we run through<br/>
	all the checks and it is valid, it will return true.
	<br/><br/><br/><br/><br/></P>
	<p>You want to use the 'def' function to print the game board so we have a<br/>
	visual of what's happening. After every three rows we want to print a<br/>
	dashed line to seperate the nine boxes with their nine elements, creating<br/>
	an organized grid. The 'end' function just makes sure that it doesn't keep<br/>
	going for the same row but starts a new one after printing nine numbers<br/>
	across. It also keeps the numbers of each row and column within formation<br/>
	of the board. The 'find_empty' is for finding a empty square on the board and<br/>
	checking if it is equal to zero, if it is we'll get a return<br/>
	of (row,col), (y,x).
	</p>
</body>
</html>