<!DOCTYPE html>
<html>
<head>
	<title>Sudoku Backtracking Game</title>
	<link rel="stylesheet" href="style.css">
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<body>
	<a href="index.html" class="button">Back</a>
	<h1>Sudoku</h1>
	<h4>Python Code:</h4>
	<h2>What I've Learned</h2>
	<p>I learned that this puzzle game is similar<br/>
	to debugging. One issue occuring from a line<br/>
	of other issues, making it so that you have<br/>
	to backtrack and see where the problem<br/>
	begins. The algorithm here will use all the<br/>
	functions throughout the coding and will <br/>
	backtrack for me. The 'find' function will<br/>
	allow me to know if there's been a solution,<br/>
	returning true if there is. Checking each<br/>
	number 1-9 and entering them into each box<br/>
	to see if it's a valid entry. If it is a<br/>
	valid entry it'll enter it into the board and<br/>
	keep trying until one of the entries are<br/>
	correct. Once it goes through all the valid <br/>
	possiblities and none are true, it will then<br/>
	backtrack to the last answer to reset because<br/>
	the current answer can't be correct.<br/>
	</p>
	
	<h3>
		# solver.py<br/>

		def solve(bo):<br/>
			find = find_empty(bo)<br/>
			if not find:<br/>
				return True<br/>
			else:<br/>
				row, col = find<br/>

			for i in range(1,10):<br/>
				if valid(bo, i, (row, col)):<br/>
					bo[row][col] = i<br/>

					if solve(bo):<br/>
						return True<br/>

					bo[row][col] = 0<br/>

			return False<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>


		def valid(bo, num, pos):<br/>
			# Check row<br/>
			for i in range(len(bo[0])):<br/>
				if bo[pos[0]][i] == num and pos[1] != i:<br/>
					return False<br/>

			# Check column<br/>
			for i in range(len(bo)):<br/>
				if bo[i][pos[1]] == num and pos[0] != i:<br/>
					return False<br/>

			# Check box<br/>
			box_x = pos[1] // 3<br/>
			box_y = pos[0] // 3<br/>

			for i in range(box_y*3, box_y*3 + 3):<br/>
				for j in range(box_x * 3, box_x*3 + 3):<br/>
					if bo[i][j] == num and (i,j) != pos:<br/>
						return False<br/>

			return True<br/><br/><br/><br/><br/><br/><br/><br/>


		def print_board(bo):<br/>
			for i in range(len(bo)):<br/>
				if i % 3 == 0 and i != 0:<br/>
					print("- - - - - - - - - - - - - ")<br/>

				for j in range(len(bo[0])):<br/>
					if j % 3 == 0 and j != 0:<br/>
						print(" | ", end="")<br/>

					if j == 8:<br/>
						print(bo[i][j])<br/>
					else:<br/>
						print(str(bo[i][j]) + " ", end="")<br/>


		def find_empty(bo):<br/>
			for i in range(len(bo)):<br/>
				for j in range(len(bo[0])):<br/>
					if bo[i][j] == 0:<br/>
						return (i, j)  # row, col<br/>

			return None<br/>
	
	
	
	</h3>
	<p>Now here is where it'll check whether the<br/>
	board is valid or not and if the number along<br/>
	with the position is also valid. We'll check<br/>
	each element for the row and see if it is<br/>
	equal to the number we added. You can not have<br/>
	the same number in a row so we'll check for<br/>
	that and make a change in our entries if<br/>
	that's the case. The same will happen for each<br/>
	column as you can not have the same number<br/>
	entry in a single column. There are nine<br/>
	boxes/sections that contain nine numbers,<br/>
	which also can't have the same number within<br/>
	any of them. Knowing the box we want to work<br/>
	on (0,1,2), then having it muliplied by 3 will<br/>
	show which column and row (position) we are<br/>
	currently working on. It will return false if<br/>
	we find a duplicate or the entry is invalid,<br/>
	but if we run through all the checks and it is<br/>
	valid, it will return true.
	<br/></P>
	<p>You want to use the 'def' function to print<br/>
	the game board so we have a visual of what's<br/>
	happening. After every three rows we want to<br/>
	print a dashed line to seperate the nine boxes<br/>
	with their nine elements, creating an<br/>
	organized grid. The 'end' function just makes<br/>
	sure that it doesn't keep going for the same<br/>
	row but starts a new one after printing nine<br/>
	numbers across. It also keeps the numbers of<br/>
	each row and column within formation of the<br/>
	board. The 'find_empty' is for finding a empty<br/>
	square on the board and checking if it is<br/>
	equal to zero, if it is we'll get a return of<br/>
	(row,col), (y,x).
	</p>
</body>
</html>